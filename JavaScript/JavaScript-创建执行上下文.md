[toc]

# JavaScript-创建执行上下文

什么是执行上下文，什么是执行上下文栈，可以看`JavaScript-执行上下文和执行栈`。

## 名词

### 标识符

通俗的讲，在JS中所有可以由我们自主命名的都可以称为是标识符， 诸如变量名、函数名、属性名都属于标识符

### 变量对象和活动对象

变量对象和活动对象是 ES3 中的概念，我们在程序中声明的变量、函数，解释器是如何并在哪找到我们的定义的数据，答案就是变量对象和活动对象了。

函数内部所有的变量和函数都保存在一个叫做变量对象中（这部分是隐式的），变量对象被调用的时候就称之为活动对象。

变量对象（variable object）下面简称VO 变量对象，就是与执行上下文相关联的特殊对象，它用来在执行上下文中存储变量、函数声明及函数的形参。它是执行上下文的一个属性。

```js
ExecutionContext = { // 执行上下文
    VO: {
        // 上下文变量
    }
}
```

执行上下文不同，变量对象的初始结构、VO的名称也不同。

- 全局执行上下文中，变量对象就是全局对象本身，在浏览器对象模型中，全局执行上下文中的变量对象就是 window 对象，是可以直接访问的。
- 函数的执行上下文-VO是不可直接访问的，它就是所谓的活动对象`activation object(AO)`（函数被调用的时候称之为活动对象）。

活动对象（activation object）下面简称AO活动对象。它存储着函数上下文中创建的变量和Arguments对象。

```js
FunctionExecutionContext = { // 函数执行上下文
    AO = { // 函数活动对象
      arguments: <ArgO>
    }
}
```

### 词法环境

词法环境是一种规范类型，代码的词法嵌套结构来定义 标识符 与特定 变量 和 函数 关联关系, 即词法环境定义了标识符（变量名）和实际变量对象的映射关系。和词法环境相关联的有 **词法环境组件** 和 **变量环境组件**。

一脸懵逼吧？这TMD都是啥？官方定义就是这样，让人知其然不知其所以然。 这里我用平民的语法来表述下什么是词法环境。

这么理解，什么是环境？不就是范围吗？什么是范围？不就是作用域吗？那词法环境不就是词法作用域吗？上解释：

> 在代码写好的时候，根据代码的书写结构就可以确定变量的作用域，这种作用域就是词法作用域，也就是词法环境。

**词法环境是一个大类，你可以把它想象成一个父组件，它有两个子组件：词法环境组件和变量环境组件**

#### 词法环境组件

词法环境组件中，主要存储的是**函数声明**和使用**let**和**const**声明变量的绑定

#### 变量环境组件

变量环境组件中，主要存储的是**函数表达式**和使用**var**声明变量的绑定

词法环境组件和变量环境组件内部还有两个组件：

+ 环境记录器：存储变量和函数声明的实际位置（类似于ES3中的变量对象）

+ 外部环境的引用：父级的词法环境（类似于[[Scope]]属性）

### 作用域

作用域，就是变量能够被引用，函数能够生效的范围及区域。

我们都知道，Js是静态作用域，也是词法作用域，代码一旦书写，就规定了该变量或函数是属于哪一个作用域。

我们也知道，Js分为全局作用域、函数作用域、块级作用域，函数级块级作用域可以访问全局作用域；嵌套函数中，内部函数可以访问外部函数的作用域...可是，为什么可以访问呢？

你可以这么解释：因为js程序书写好的时候，根据代码的书写结构就可以确定变量的作用域，所以局部的可以访问全局的，嵌套函数中，内部的可以访问外部的。

是吗？这个仅仅是表象，以函数作用域为例，实际上：

>  一个函数在创建的时候，都会创建一个内部属性[[Scope]]，其包含着该函数被创建时的父级上下文中的变量对象（事实上，函数是在创建父级执行上下文的过程中被创建的）；
>
> 该函数在被调用时，函数的执行上下文作用域链，不仅包含着该函数的活动对象AO，也包含着该函数的[[Scope]]属性的拷贝。

举例：

```js
var x = 10
function foo() {
    var y = 20
}
foo()
```

对于上述代码，上下文环境创建是按照：

1. 创建全局上下文环境

```js
GlobalContext = {
  VO: {
    x: 10,
    foo: <reference> to Function foo
  },
  this: windows
}
```

2. foo创建后，就会同时创建他的内部属性[[Scope]]，包含父级上下文对象。

```js
foo.[[Scope]] = {
  VO: GlobalContext.VO,
  this: windows
}
```



3. foo调用后，创建自己的执行上下文环境。

```js
FooContext = {
  AO: {
    y: 20,
    this: windows
  }
}
```

4. foo的作用域链为：

```js
FooContext.Scope = {
  AO: FooContext.AO,
  VO: GlobalContext.VO //也就是foo.[[Scope]]的拷贝
}
```

上文提到，ES3 和 ES5中，对变量存储的定义完全不同，在ES5中，变量对象的概念已被词法环境模型所取代，所以下面分开讲述下 ES3 和 ES5 中创建上下文的过程。

## ES3中执行上下文创建的过程

让我们通过代码及伪代码来具体分析下，ES3中是如何创建上下文的：

```js
var x = 10;
function foo() {
  var y = 20;
  function bar() {
    var z = 30;
    alert(x +  y + z);
  }
  bar();
}
foo(); 
```

1. 运行代码，首先创建全局执行上下文对象。

```js
GlobalContext = {
  VO: {
   	x: undefined,
  	foo: <reference> to Function foo,
  	this: windows 
  }
}
```

2. 此时函数foo被创建，所以他有了自己的隐藏对象[[Scope]]。

```js
foo.[[Scope]] = {
  VO: {
    x: undefined,
    foo: <reference> to Function foo,
    this: windows
  }
}
```

3. 全局变量对象初始化完毕后, 进入执行阶段，执行阶段先对全局变量对象进行更新赋值(GlobalVO)如下:

```js
GlobalContext = {
  VO: {
   	x: 10,
    this: window,
    foo: <reference> to Function foo 
  }
}
// 同理，foo函数的[[Scope]]属性也就变成
//（因为仅仅是对父级变量对象的引用，下文此类情况不再提及）
// foo.[[Scope]] = {
//    VO: {
//        x: 10,
//        this: window,
//        foo: <reference> to Function foo
//    }
// }
```

4. 调用foo函数（一旦调用函数，就要创建函数执行上下文）,开始创建foo函数执行上下文：首先，初始化变量，并填充到 foo 的活动对象(AO)中；其次，还记得上面创建foo函数时，foo函数内部的[[Scope]]属性吗？foo执行上下文拷贝函数内部[[Scope]]属性保存在上下文中的作用域链中，并将刚刚填充的AO放入执行上下文作用域链的最顶端；此时foo上下文中的活动对象/变量对象如下:

```js
FooContext = {
    AO: {
        y: undefined, // 预编译阶段不赋值
        this: window,
        arguments: [],
        bar: <reference> to Function bar // 创建了 bar 函数
    },
    VO: {
        x: 10,
        this: window,
        foo: <reference> to Function foo
    }
}
```

5. 此时，bar函数已经被创建，所以bar函数创建了内部属性[[Scope]]，其包含着对父级上下文活动对象/变量对象的引用（在这里为foo函数上下文的活动对象/变量对象）

```js
bar.[[Scope]] = {
    AO: {
        y: undefined,
        this: window,
        arguments: [],
        bar: <reference> to Function bar
    },
    VO: {
        x: 10,
        this: window,
        foo: <reference> to Function foo
    }
}
```

6. 执行foo函数, 进行更新赋值操作

```js
FooContext = {
    AO: {
        y: 20,
        this: window,
        arguments: [],
        bar: <reference> to Function bar
    },
    VO: {
        x: 10,
        this: window,
        foo: <reference> to Function foo
    }
}
```

7. 调用bar函数,调用前先创建bar函数执行上下文，如何创建呢？同foo一样，首先将 bar 的活动对象放入bar的执行上下文作用域链的顶部；其次，将bar函数内部属性[[Scope]]拷贝至bar函数执行上下文的作用域链中。此时 bar 的上下文如下

```js
BarContext = {
    AO: {
        z: undefined,
        this: window,
        arguments: []
    },
    AO: {
        y: 20,
        this: window,
        arguments: [],
        bar: <reference> to Function bar
    },
    VO: {
        x: 10,
        this: window,
        foo: <reference> to Function foo
    }
}
```

执行bar函数, 进行赋值操作:

```js
BarContext = {
    AO: {
        z: 30,
        this: window,
        arguments: []
    },
    AO: {
        y: 20,
        this: window,
        arguments: [],
        bar: <reference> to Function bar
    },
    GO: {
        x: 10,
        this: window,
        foo: <reference> to Function foo
    }
}
```

>  在 bar 函数中，执行 alert(x + y + z)
>
> - x: 在当前执行上下文中 (BarContext)中查找变量x，在VO中找到，为10
> - y: 在当前执行上下文中 (BarContext)中查找变量y，在第二层AO中找到，为20
> - z: 在当前执行上下文中 (BarContext)中查找变量z，在第一层AO中找到，为30
>
> - bar函数执行完成，其执行上下文弹出执行栈，执行权交还给foo执行上下文
> - foo执行完，其执行上下文弹出执行栈，执行权交还给全局执行上下文
> - 全部代码执行完，关掉浏览器，执行栈清空

1. ES3中主要围绕的是**变量对象**和**活动对象**来创建执行上下文
2. 每次进入上下文时都会创建并用初始值填充变量对象（**变量提升**） ，并且其更新发生在代码执行阶段
3. js的预解析其实就是发生在创建变量对象的过程中，使用初始值填充变量对象；同时，预解析只解析当前上下文中的变量。所以，你写好的程序，运行在浏览器时，只会解析全局变量对象，如果有函数，你不调用，函数内部的代码是不会进行预解析的！
4. 函数声明会在进入上下文阶段时放入变量/激活对象（VO / AO）中
5. 函数生命周期分为创建阶段和激活阶段（调用），创建阶段会创建内部属性[[Scope]]，包含着对外部变量的引用
6. 函数上下文的作用域链是在函数调用时创建的，由激活对象和该函数的内部[[Scope]]属性组成
7. js就是通过作用域链的规则来进行变量查找（准确的说应该是执行上下文的作用域链）

## ES5中执行上下文创建的过程

ES5创建执行上下文与ES3过程类似，只是执行上下文中的解构不同，它主要分为3个步骤

1. 绑定this值
2. 创建词法环境组件(let和const变量的绑定，函数声明)
3. 创建变量环境组件(var变量的绑定和函数表达式)

上文说到，词法环境组件和变量环境组件都是词法环境，它们都有环境记录器和对外部环境的引用

实在不好理解，你可以简单的把环境记录器看成是ES3中的变量对象或活动对象，把对外部环境的引用看成执行上下文中的作用域。为什么呢？首先，环境记录器分为两种：声明式环境记录器和对象环境记录器，可以把它们分别对应为活动对象和变量对象；也就是说：

在全局环境中，ES5中用对象环境记录器来存储变量和函数，ES3中用变量对象来存储变量和函数

在函数环境中，ES5中用声明式环境记录器来存储变量和函数，ES3中用活动对象来存储变量和函数

用伪代码来表示ES5中执行上下文如下：

```js
ExecutionContext = {
    ThisBinding = <this value>,
    // 词法环境
    LexicalEnvironment = {
        // 环境记录器，存储着该上下文中通过let const声明的变量，及函数声明
        // 根据上下文类型，可以理解为变量对象或活动对象
        EnvironmentRecord: {},
        // 当前上下文对外部环境引用，及作用域
        outer: <>
    },
    // 变量环境
    VariableEnvironment = {
        // 环境记录器，存储着该上下文中通过var声明的变量，及函数表达式
        // 根据上下文类型，可以理解为变量对象或活动对象
        EnvironmentRecord: {},
        // 当前上下文对外部环境引用，及作用域
        outer: <>
    },
}
```

除了创建上下文结构的不同，ES3和ES5对于 js 程序的解析和执行过程都是相同的，所以，如果你理解了 es3 对于上下文的创建过程，那么理解 es5 基本也不在话下了。

## 参考

大王叫我来爬山-[深入js基础：从内存机制、解析机制到执行机制（长文预警）](https://juejin.im/post/6844904005785616397#heading-14)

