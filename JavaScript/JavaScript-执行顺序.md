[toc]

# JavaScript-执行顺序

## 进程与线程

对于进程和线程傻傻分不清？没关系，老规矩，上定义：

>- 进程是操作系统分配资源和调度任务的基本单位
>- 线程是建立在进程上的一次程序运行单位，一个进程上可以有多个线程。

抛开官方枯燥的定义，平民化定义进程与线程，拿钻孔台车举例，钻孔台车分单臂和多臂，上图：

<img src="https://imgedu.lagou.com/98e5489361ec469480299748351ce616.jpg"/>

重新定义下进程与线程

>- 进程是你能拿出的钻孔台车的数量，如果你能拿出一台，就是单进程，如果能拿出多台，就是多进程
>- 线程是建立在钻孔台车种类的基础上，你是单臂还是多臂，如果是单臂，就是单线程，多臂就是多线程

这下彻底明白了吧？众所周知，js是单线程语言，也就是单臂，一次只能干一个事；而浏览器是多进程多线程，你可以一次开启多个浏览器标签，这是多进程的体现；每个浏览器标签中(浏览器内核)是多线程，其分为GUI渲染线程、JS引擎线程、事件触发线程、定时触发器线程、异步HTTP请求线程。对于具体的线程，我们下面在将js执行机制时在详细阐述。

## 协程

这里对协程的介绍，参考了阮一峰老师在ECMAScript 6 入门中对Generator 函数的介绍，其作用是为了更好的控制异步任务的流程，具体送上[传送门](https://es6.ruanyifeng.com/#docs/generator-async)

因为除了在es6中协程的体现并不是很明显，所以这里不做展开。

## JS的执行机制

js代码要想运行，必须经过预解析和执行两个阶段。

上文中，我们花了很大篇幅去讲js执行上下文及其创建的过程，其实上下文创建的过程，完全可以理解为js的解析机制，在解析完后，上下文创建ok了，此时就需要执行代码了。

你可能要说了，还能怎么执行，按顺序从上到下执行呗。

非也，js代码也有好多种，同步、异步、定时器、绑定事件、ajax请求等等。js的执行机制，规定了代码的执行顺序，从而确保了一个单线程语言，不会因为某段代码执行时间过长而造成阻塞，这种执行机制，就是 js 的事件循环。

其实，在解释事件循环的概念时，很多文章提及到了**同步任务**和**异步任务**，**微任务**和**宏任务**。结合代码，基本分析如下：

```js
console.log(1) // 同步
setTimeout(function() {// 异步
    console.log(2)
}, 10)
console.log(3) // 同步
// 执行栈中，同步先执行，输出 1
// 异步任务的回调函数加入到任务队列。
// 接着同步任务，输出 3
// 同步任务执行完成，如果异步任务有了结果（10ms过后）
// 将任务队列中异步的回调函数加入到执行栈中执行，输出2
// 结果：1 3 2
```

可是一旦加入Promise和process.nextTick，局面就不一样了

```js
console.log(1) // 同步
setTimeout(function() {// 异步
    console.log(2)
}, 10)
new Promise((resolve) => {
    console.log('promise') // 同步
    resolve()
}).then(() => {
    console.log('then') // 异步
})
console.log(3) // 同步
// 执行栈中，同步先执行，输出 1
// 异步任务的回调函数加入到任务队列。（console.log(2)和console.log('then')）
// 接着同步任务，输出 promise 和 3
// 同步任务执行完成，如果异步任务有了结果（10ms过后）
// 将任务队列中异步的回调函数加入到执行栈中执行，输出 2 then(队列先进先出)
// 理想结果：1 promise 3 2 then
// 正确输出：1 promise 3 then 2
```

结果对吗？显然不对，两个异步任务`console.log(2)`和`console.log('then')`执行顺序错了，队列不是先进先出的吗？2先进去，then后进去，为什么执行结果反过来了？它们都是异步任务，这时单单拿同步和异步来解释已经解释不同了。

所以，很多文章自然引出了**微任务**和**宏任务**

宏任务：整体代码script，setTimeout，setInterval

微任务：Promise，process.nextTick

执行机制变成：先执行整体代码(宏任务)，执行完成后，执行微任务，微任务执行完，第一轮事件循环完毕；开启第二轮：读取任务队列，看是否有宏任务，如果有就执行......

上面代码，因为`promise`是微任务，所以它优先于`setTimeout`执行。

确实这么解释并没有错，而且是正确的，这里我并没有对他们的解释进行反驳。但是这样解释带来的疑惑就是：

>1. 任务队列是啥？
>2. 怎么划定宏任务和微任务？
>3. 我怎么知道整体代码script是宏任务，Promise是微任务？全凭记忆？
>4. 异步ajax是微任务还是宏任务？
>5. 用户点击事件的回调是微任务还是宏任务？

这么多疑问，没关系，让我带着你们一一破解。首先有必要先了解下浏览器内核。

### 浏览器内核线程和事件队列

在介绍进程和线程时我们谈到了浏览器内核是多线程的，它包括如下几个线程：

> + GUI渲染线程：主要用来处理DOM树解析，渲染，重绘（与DOM相关）等
>
> + JS引擎线程：执行javascript脚本
>
> + 事件触发线程：负责管理**事件队列**，并交给 js 引擎线程执行。诸如DOM绑定的事件（onclick，onmouseenter等）、定时器计时结束、请求结束，当满足条件后，对应的回调函数会添加到**事件队列**（也就是任务队列）中。
>
> - 事件队列：主要是来存放不同事件（定时器，用户触发的事件，请求事件）的回调函数，当达到了相应的条件（如定时器到时，用户点击按钮，请求完成并响应）后，事件触发线程，会将满足条件的回调函数，添加到 js 引擎线程中的任务队列中等待执行。
>
> + 定时器线程：setTimeout、setInterval所在的线程，主要对定时器进行计时，定时时间到后，由事件触发线程将回调函数添加到**事件队列**中
>
> + 异步网络请求线程：在该线程内进行异步请求，请求状态变更后，如果有回调，由事件触发线程将回调处理添加到**事件队列**中

<img src="https://imgedu.lagou.com/53b084d9ad5f43f7b6f1b9ec6a5923df.jpg"/>

结合浏览器内核，我们来看看什么是微任务和宏任务，这里再一次列出部分文章对微任务宏任务的说明：

宏任务：整体代码script，setTimeout，setInterval

微任务：Promise，process.nextTick

### 宏任务

>首先明确，宏任务和微任务，都是异步任务

所谓的宏任务，就是需要其它线程处理的任务，这里的其它线程包括`JS引擎线程`，`事件触发线程`，`定时器线程`，`异步网络请求线程`，所以一旦和上面4个线程挂钩，它就是宏任务。我们拿上面列出的宏任务一一解释下：

- 整体代码script （JS引擎线程）
- setTimeout，setInterval （定时器线程）
- ajax异步请求（异步网络请求线程）
- onclick事件绑定（事件触发线程）

是不是比上面给出的宏任务种类多？所以，记住：凡是涉及到浏览器内核线程的任务，都是宏任务。

### 微任务

微任务通常来说就是需要在当前任务执行结束后立即执行的任务，比如异步的任务但又不需要**除** `JS引擎线程` 处理的任务（除字很关键！）。

首先它是异步的，其次，它不需要诸如`事件触发线程`或`定时器线程`或`异步网络请求线程`来处理。来看看Promise，process.nextTick，浏览器中有专门的内核线程来处理吗？你可能会说它是由`JS引擎线程`执行的啊，确实，但它是个异步，所以是微任务。

你可以这么理解：不是宏任务的任务就是微任务。

## 事件循环

罗嗦一大堆，终于来到事件循环了，有了前面理论的铺垫，事件循环就很好理解了。

再回味下，事件循环就是 Javascript 的执行机制，即，规定了 Javascript 代码执行的流程：

> 1. 执行整段 `JavaScript` 代码，将整段代码中的同步任务放入执行栈中执行（上面说了，这个是宏任务）
>
> 2. 代码中如果有 `setTimeout` 或 `ajax`等宏任务，会利用对应的浏览器的内核线程来处理，达到条件（定时器时间达到，请求完成）后，由`事件触发线程`将其对应的回调加入到**事件队列（任务队列）中**
>
> 3. 如果有`Promise`等微任务，加入微任务队列，在执行栈执行完当前的同步任务的之后，从微任务队列中取出微任务，立即执行
>
> 4. **所有的微任务**执行完，此时，执行栈中处于闲置状态（注意：本轮事件循环中所有微任务执行完，开启下轮循环）
>
> 5. 以上是第一轮事件循环，以下开始第二轮：
>
> 6. 事件队列将队列中的任务加入到执行栈，按先进先出的顺序执行
>
> 7. 如果此时进入栈中的任务既有同步任务，微任务和宏任务，那先执行同步任务
>
> 8. 再执行所有的微任务
>
> 9. 第二轮事件循环结束，开始第三轮循环：
>
> 10. 执行宏任务...循环往复，直到所有任务执行完毕。

下面用三段代码由浅入深的分析下：

### 案例一：只有宏任务

```js
console.log(111)
setTimeout(function() {
    console.log(222)
}, 5000)
$.ajax({
    url: '',
    success: function() {
        console.log(333)
    }
})
console.log(444)
// 预计输出 
//如果ajax请求大于5000: 111 444 222 333
//如果ajax请求小于5000: 111 444 333 222
```

运行代码，先执行整段代码的同步任务`console.log(111)`，输出 111

遇到 `setTimeout`，将其交给`定时器线程`处理

遇到 `ajax`请求，将其交给`异步网络请求线程`处理，

- 注意：此时事件队列只有一个任务： `ajax成功的回调`（前提是，这个请求开始到结束响应耗时低于5秒，以下默认不解释）
- 咦？为什么呢？实际上，前面也说了，`setTimeout`是在`定时器线程`中计时，5秒后才放入事件队列中，而此时，ajax执行很快，还不到5秒，所以`setTimeout`的回调还不会加入到事件队列中

执行同步代码`console.log(444)`，输出 444

因为此代码没有微任务，所以第一轮事件循环结束，准备开始第二轮事件循环

同步代码执行完，此时执行栈为空，要去事件队列中取任务

- 此时注意下，可能事件队列中还没有任务
- 因为`定时器线程`5秒后，才由`事件触发线程`将其回调函数交给事件队列
- 同时，`异步网络请求线程`，在请求完成响应200后，才由`事件触发线程`将其成功的回调函数交给事件队列
- 所以，如果请求时间过长，或执行之前的代码时间不足5秒，事件队列都有可能为空

假设，ajax请求时间为2秒，此时事件队列中就有了`ajax`成功的回调，取出该回调，输出 333

5秒后，`定时器线程`将`setTimeout`的回调加入到事件队列中

因为执行栈已经为空，所以直接取事件队列中的`setTimeout`的回调，输出222

结果：111 444 333 222

如果ajax请求时间大于定时器的5秒，那么结果是：111 444 222 333

>+ 因为不好限制请求耗时，下面将setTimeout的定时均设置为0
>
>+ setTimeout定时设置为0的意思是：运行代码时，一旦运行到setTimeout这行，`定时器线程`会立即把`setTimeout的回调`放入事件队列中，一旦执行栈空闲，立即取出执行。
>
>+ 此时，就不存在ajax和setTimeout不好判断的问题了。事件队列中，ajax的回调会一直在setTimeout回调之后

### 案例二：宏任务和微任务（一）

```js
console.log(111)
setTimeout(function() {
    console.log(222)
}, 0)
new Promise((resolve) => {
    console.log('333')
    resolve()
}).then(() => {
    console.log('444')
})
$.ajax({
    url: '',
    success: function() {
        console.log(555)
    }
})
console.log(666)

//预计输出： 111 333 666 444 222 555
```

> 运行代码，先执行整段代码的同步任务`console.log(111)`，输出 111
>
> 遇到 `setTimeout`，将其交给`定时器线程`处理，0秒后，才由`事件触发线程`将其回调函数交给事件队列
>
> 遇到 `Promise`，Promise为立即执行函数，所以输出 333
>
> 它有一个 `then` 回调，是个微任务，先不执行
>
> 遇到 `ajax`请求，将其交给`异步网络请求线程`处理，请求完成响应200后，由`事件触发线程`将其成功的回调函数交给事件队列
>
> - 此时假设ajax请求完成，故现在的事件队列为 ①`setTimeout回调`，②`ajax回调`
>
> 执行同步代码`console.log(666)`，输出 666
>
> 同步任务执行完，查看是否有微任务，有微任务，为 `then` 回调，开始执行，输出 444
>
> 没有其他微任务了，此时执行栈为空，第一轮事件循环结束，准备开始第二轮事件循环
>
> 去事件队列中取任务
>
> 首先取出`setTimeout`的回调，输出 222
>
> 然后取出`ajax`的回调，输出 555
>
> 结果：111 333 666 444 222 555

### 案例三：宏任务和微任务（二）

```js
console.log(111)
new Promise((resolve) => { // promise1
  console.log(222)
  new Promise((resolve) => { // promise2
    console.log(333)
    resolve()
  }).then(() => {
    console.log(444)
  })
  resolve()
}).then(() => {
  console.log(555)
  new Promise((resolve) => { // promise3
    console.log(666)
    resolve()
  }).then(() => {
    console.log(777)
  })
})
setTimeout(function() {
  console.log(888)
}, 0)
console.log(999)

//预计输出： 111 222 333 999 444 555 666 777 888
```

> 执行代码，当前执行栈为全局执行上下文栈，执行第一行代码`console.log(111)`，输出 111
>
> 遇到promise1，立即执行，输出 222
>
> promise1内部还包含 promise2，立即执行，输出 333，将 promise2 的then回调加入到微任务队列
>
> promise1 的then回调加入到微任务队列，它在promise2 的then回调之后
>
> 遇到 setTimeout，将其交给`定时器线程`处理，0秒后，才由`事件触发线程`将其回调函数交给事件队列
>
> 执行最后一行代码，输出 999
>
> 执行完所有同步任务，执行栈此时没有任务了，有微任务吗？有，微任务队列中有两个微任务，依次取出
>
> 取出第一个微任务，为 promise2 的then回调，加入到执行栈执行，输出 444
>
> 取出第二个微任务，为 promise1 的then回调，加入到执行栈执行，输出 555，此时promise1 的then回调中又包含了 promise3，执行promise3，输出 666，将promise3 的then回调加入到微任务队列
>
> 执行栈任务为空，微任务队列中有任务吗？有，为刚刚加入的 promise3 的then回调
>
> 取出promise3 的then回调，加入到执行栈执行，输出 777
>
> 微任务队列为空了，第一轮事件循环执行完毕，开始第二轮循环，去事件队列中取任务
>
> 执行setTimeout的回调，输出 888，没有其他任务了，事件循环结束
>
> 结果：111 222 333 999 444 555 666 777 888

### 案例四：宏任务和微任务互相嵌套

```js
console.log(000)
setTimeout(function() {
  console.log(111)
  setTimeout(function() {
    console.log(222)
    new Promise((resolve) => {
      console.log(333)
      resolve()
    }).then(() => {
      console.log(444)
    })
  }, 0)
}, 0)

new Promise((resolve) => {
  console.log(555)
  resolve()
}).then(() => {
  new Promise((resolve) => {
    console.log(666)
    setTimeout(function() {
      resolve()
    }, 0)
  }).then(() => {
    console.log(777)
    setTimeout(function() {
      console.log(888)
    }, 0)
  })
})

$.ajax({
  url: '',
  success: function() {
    console.log(999)
  }
})

console.log(1010)
```

> 执行代码，当前执行栈为全局执行上下文栈，执行第一行代码`console.log(000)`，输出 0
>
> 遇到第一个`setTimeout`（这里叫它setTimeout1回调），将其交给`定时器线程`处理，0秒后，才由`事件触发线程`将其回调函数交给事件队列
>
> - 事件队列目前有：①`setTimeout1回调`
>
> 遇到 `Promise`，立即执行，输出 555，其 `then` 回调为微任务，先不执行
>
> 遇到ajax，将其交给`异步网络请求线程`处理，假设该请求耗时10秒，10秒后，由`事件触发线程`将其成功的回调函数交给事件队列
>
> 执行最后一行同步代码`console.log(1010)`，输出 1010
>
> 同步代码执行完，有微任务吗？有，promise的`then`回调函数，执行
>
> 该`then`回调中又包含一个 `Promise`，先执行 `Promise`，输出 666，其 `then` 回调为微任务，先不执行
>
> 然后看到该`Promise`还包含`setTimeout`（这里叫它setTimeout2回调），所以将其交给`定时器线程`处理，0秒后，才由`事件触发线程`将其回调函数交给事件队列
>
> - 事件队列目前有：①`setTimeout1回调`，②`setTimeout2回调`
>
> 因为其 `resolve` 在setTimeout中，故，此轮微任务不执行该 `then`回调
>
> 还有微任务吗？没了，全局执行上下文栈也为空了。第一轮事件循环结束，准备开始第二轮事件循环
>
> 去事件队列中取任务，事件队列目前有：①`setTimeout1回调`，②`setTimeout2回调`
>
> 先取出`setTimeout1回调`，执行，首先输出 111
>
> 它内部还有 `setTimeout`（这里叫它setTimeout3回调），将其交给`定时器线程`处理，0秒后，才由`事件触发线程`将其回调函数交给事件队列
>
> - 事件队列目前有：①`setTimeout2回调`，②`setTimeout3回调`
>
> 执行完setTimeout，有微任务吗？没有，全局执行上下文栈为空了。第二轮事件循环结束，准备开始第三轮事件循环
>
> 去事件队列中取任务，事件队列目前有：①`setTimeout2回调`，②`setTimeout3回调`
>
> 先取出`setTimeout2回调`，执行，setTimeout2的回调函数是啥呢？还记得第一轮事件循环中的 `resolve` 吗？
>
> 执行`resolve`，即promise的then回调，输出 777
>
> 它内部还有 `setTimeout`（这里叫它setTimeout4回调），将其交给`定时器线程`处理，0秒后，才由`事件触发线程`将其回调函数交给事件队列
>
> - 事件队列目前有：②`setTimeout3回调`，④`setTimeout4回调`
>
> 执行完setTimeout2，有微任务吗？没有，全局执行上下文栈为空了。第三轮事件循环结束，准备开始第四轮事件循环
>
> 先取出`setTimeout3回调`，执行，首先输出 222
>
> setTimeout3内部有 Promise，执行，输出 333
>
> 有微任务吗？有，为promise的then回调，执行，输出 444
>
> 没有微任务了，全局执行上下文栈为空了。第四轮事件循环结束，准备开始第五轮事件循环
>
> 先取出`setTimeout4回调`，执行，输出 888
>
> 有微任务吗？没有，全局执行上下文栈为空了。第五轮事件循环结束
>
> 10秒过后，事件队列中有了`ajax`的回调
>
> 全局执行上下文栈此时为空，所以立即取出`ajax`的回调，执行，输出 999

> 结果为：0, 555, 1010, 666, 111, 777, 222, 333, 444, 888, 999

个人觉得还是有一点遗憾，没有把JS的执行机制和执行栈相关联进行解释，下面最后一个案例，让我们彻底把JS执行机制和上下文结合起来进行分析。

```js
<script>
console.log(111)
function foo() {
  new Promise(function(resolve) { // Promise1
    console.log(222)
    resolve()
  }).then(function() {
    console.log(333)
  })
  setTimeout(function() { // setTimeout1
    console.log(444)
  }, 0)
}
foo()
new Promise((resolve) => { // Promise2
  console.log(555)
  resolve()
}).then(() => {
  console.log(666)
})
setTimeout(function() { // setTimeout2
  console.log(777)
}, 0)
console.log(888)
</script>
```

> 全部代码进入浏览器运行，此时要创建全局上下文栈，如何创建过程就不重复讲解了。
>
> 创建完成，在全局上下文栈中执行同步任务，**输出 111**
>
> 遇到函数foo的调用，开始创建foo函数执行上下文栈
>
> - 此时的执行栈为：[foo函数栈，全局栈]
>
> 在foo函数执行上下文栈中，遇到Promise1，它的第一个参数为立即执行的，而且参数为一个匿名函数
>
> 创建匿名函数执行上下文栈（这里叫它匿名栈1），执行`console.log(222)`，**输出 222**；遇到调用resolve，注意：这个resolve()是将Promise对象的状态从“未完成”变为“成功”，因为此处Promise1中没有异步任务，所以等`console.log(222)`执行完，会立即调用resolve。
>
> - 此时的执行栈为：[匿名栈1，foo函数栈，全局栈]
>
> 调用resolve，创建匿名函数执行上下文栈（这里叫它匿名栈2），此时程序跳到 then 方法，因为Promise的 then 方法是一个微任务，所以此时不会执行，将其放入微任务队列中待执行。
>
> - 此时的执行栈为：[匿名栈2，匿名栈1，foo函数栈，全局栈]
>
> resolve调用时创建的匿名函数执行上下文栈出栈
>
> - 此时的执行栈为：[匿名栈1，foo函数栈，全局栈]
>
> resolve调用完后，Promise1中第一个匿名函数没有其他执行的代码，所以匿名栈1也出栈
>
> - 此时的执行栈为：[foo函数栈，全局栈]
>
> 此时执行上下文栈为 foo 函数栈，foo函数内部还有个 setTimeout，将它（setTimeout1）交给`定时器线程`处理，0秒后，才由`事件触发线程`将其回调函数交给事件队列
>
> foo函数执行完毕，foo函数栈出栈
>
> - 此时的执行栈为：[全局栈]
>
> 回到了全局执行上下文栈中，遇到Promise2，立即执行它的第一个回调函数，创建匿名函数执行上下文栈（匿名栈3）
>
> - 此时的执行栈为：[匿名栈3，全局栈]
>
> 在当前匿名栈3中，执行**输出 555**，调用resolve（同上，此处不在详细书写栈的变化），将其 then 回调放入微任务队列
>
> - 此时微任务队列中为：[Promise1的then，Promise2的then]
>
> 匿名函数执行完，匿名栈3出栈
>
> - 此时的执行栈为：[全局栈]
>
> 回到全局栈，遇到setTimeout2，交给`定时器线程`处理，0秒后，才由`事件触发线程`将其回调函数交给事件队列
>
> - 事件队列此时为：[setTimeout1回调，setTimeout2回调]
>
> 执行最后一行代码，**输出 888**
>
> 全局栈中同步代码执行完毕，取出微任务队列执行
>
> - 微任务队列为[Promise1的then，Promise2的then]，秉承先进先出的原则
>
> 先执行Promise1的then回调，同样，创建匿名函数执行上下文栈（匿名栈4），创建完后执行，**输出 333**
>
> - 此时的执行栈为：[匿名栈4，全局栈]
>
> 匿名栈4出栈，此时的执行栈为：[全局栈]
>
> 再执行Promise2的then回调，同样，创建匿名函数执行上下文栈（匿名栈5），创建完后执行，**输出 666**
>
> - 此时的执行栈为：[匿名栈5，全局栈]
>
> 执行完后，匿名栈5出栈，此时的执行栈为：[全局栈]，同时微任务队列为空，第一轮事件循环结束，开始第二轮
>
> 取出事件队列中的任务，事件队列为：[setTimeout1回调，setTimeout2回调]，秉承先进先出的原则
>
> 先执行setTimeout1回调，同样，创建匿名函数栈6，执行**输出 444**，匿名栈6出栈，回到全局栈
>
> 再执行setTimeout2回调，同样，创建匿名函数栈7，执行**输出 777**，匿名栈7出栈，回到全局栈

> 结果：111 222 555 888 333 666 444 777

## 参考

大王叫我来爬山-[深入js基础：从内存机制、解析机制到执行机制（长文预警）](https://juejin.im/post/6844904005785616397#heading-14)

