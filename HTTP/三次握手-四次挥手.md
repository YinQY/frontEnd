[toc]

# 三次握手和四次挥手

## 三次握手

1. 第一次客户端发送`syn = 1，seq = x`的包给服务端，发送完毕后，客户端进入`syn-send`状态。

2. 服务端接收到客户端发送的包，发回应答包，`syn = 1,ack(ACK) = 1,seq = y,ackNum(ack) = x + 1`，表示已经收到了客户端发送的包，现在服务端处于，`syn-received`状态。
3. 客户端接收到服务端的应答包，发送`ack(ACK) = 1,ack = y + 1,seq = x + 1`的确认包，发送完毕后，客户端进入`established`状态，服务端接收到此包后，也进入`established`状态，连接建立完成。

> 三次挥手示意图

<img src="https://raw.githubusercontent.com/HIT-Alibaba/interview/master/img/tcp-connection-made-three-way-handshake.png"/>

其中，刚刚开始，客户端处于`closed`状态，服务端处于`listen`状态。

> 为什么要三次握手?

第一次握手：客户端发送包，服务端接收到包，此时，服务端可以得出结论——客户端发送和服务端接收信息正常。

第二次握手：服务端发送包，客户端接收包，此时，客户端可以得出结论——客户端发送、接收信息正常，服务端发送、接收信息正常。但服务端不能确认客户端是否接受信息正常，所以进行第三次握手。

第三次握手：服务端和客户端互相确认自己和对方的发送和接受信息正常，所以进入连接。

### 半连接队列

服务端第一次接收到客户端的请求，进入`syn-received`状态，双方还没有完全建立连接，此时服务端会把这些连接放入一个队列中，这个队列就是半连接队列。

如果服务端和客户端完全建立连接，那么就会把连接放入全连接队列中。当然，如果队列满了，就会出现丢包的现象。

> syn-ack重传

服务端第一次接收到客户端的连接后，发送应答包，如果没有收到客户端的应答包，则在规定时间内会重新发送应答包，这就叫重传。一段时间后如果还未收到应答包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…

### ISN(initial sequence number)

当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN。ISN可以看作是一个32比特的计数器，每4ms加1 。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。

三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。

### 三次握手可以携带数据吗

第一次和第二次不允许携带数据，第三次可以。因为如果第一次携带数据，那么会导致包非常大，服务端会消耗大量的内存来储存这些数据，这会给攻击者带来便利。

### syn攻击

syn攻击就是攻击者用大量的伪造ip地址给服务端发送tcp请求，因为源地址不存在，导致服务端要进行多次重传，占用半连接和未连接队列，使得正常的syn请求遭到抛弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。

SYN 攻击是一种典型的 DoS/DDoS 攻击。

- 如何检测 SYN 攻击？

  检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。

  ```shell
  etstat -n -p TCP | grep SYN_RECV
  ```

- 如何防御 SYN 攻击？

  SYN攻击不能完全被阻止，除非将TCP协议重新设计。我们所做的是尽可能的减轻SYN攻击的危害，常见的防御 SYN 攻击的方法有如下几种：

  - 缩短超时（SYN Timeout）时间
  - 增加最大半连接数
  - 过滤网关防护
  - SYN cookies技术

## 四次挥手

服务端和客户端都可以主动发送`close`命令进行连接关闭。

1. 第一次挥手：客户端发送`FIN = 1,seq = x`的包，表示没有数据要发送了，但是还可以接受服务端的数据。此时客户端进入`FIN_WAIT_1`状态。
2. 第二次挥手：服务端接收到客户端的包，发送`ACK = 1,ack = x + 1`的应答包，表示接受客户端的连接关闭请求，但是自己还没有进入连接关闭状态。发送完毕后，服务端进入`close-wait`状态，等待自己的连接关闭。客户端接受到服务端的应答包后，进入`FIN_WAIT_2`状态，表示等待服务端关闭连接。
3. 第三次挥手：服务端准备好关闭连接后，发送`FIN = 1,ack = y`的包给客户端，发送完毕后，服务端进入`LAST_ACK`状态。
4. 第四次挥手：客户端接收到服务端的请求后，发送`ACK = 1,ack = y + 1`的应答包，连接正式关闭。服务端接收到应答包后进入`closed`状态。客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 `CLOSED` 状态。

> 四次挥手示意图：

<img src="https://raw.githubusercontent.com/HIT-Alibaba/interview/master/img/tcp-connection-closed-four-way-handshake.png"/>

### 为什么四次挥手

因为服务端在接收到客户端的关闭请求后，有可能还要发送其他数据给客户端，所以服务端只能先发送一个ack包给客户端，表示我已经接收到关闭请求，但是我目前还不能关闭。等服务端所有都处理完，才能发送fin包给客户端，表示我这里也要关闭连接。

### 2MSL等待状态

最后客户端需要等待2msl是因为防止服务端超时重发。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。

有两个理由：

- **保证客户端发送的最后一个ACK报文段能够到达服务端。**

这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。

- **防止“已失效的连接请求报文段”出现在本连接中。**

客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。

## 总结

《TCP/IP详解 卷1:协议》有一张TCP状态变迁图，很具有代表性，有助于大家理解三次握手和四次挥手的状态变化。如下图所示，粗的实线箭头表示正常的客户端状态变迁，粗的虚线箭头表示正常的服务器状态变迁。

![img](https://picb.zhimg.com/80/v2-7c402fde8210519feb8f65d41410c205_1440w.jpg)

参考：[知乎-老刘-面试官，不要再问我三次握手和四次挥手](https://zhuanlan.zhihu.com/p/86426969)

